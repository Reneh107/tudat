/*    Copyright (c) 2010-2016, Delft University of Technology
 *    All rights reserved.
 *
 *    Redistribution and use in source and binary forms, with or without modification, are
 *    permitted provided that the following conditions are met:
 *      - Redistributions of source code must retain the above copyright notice, this list of
 *        conditions and the following disclaimer.
 *      - Redistributions in binary form must reproduce the above copyright notice, this list of
 *        conditions and the following disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *      - Neither the name of the Delft University of Technology nor the names of its contributors
 *        may be used to endorse or promote products derived from this software without specific
 *        prior written permission.
 *
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
 *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 *    OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    Changelog
 *      YYMMDD    Author            Comment
 *      120203    B. Tong Minh      Copied RungeKutta4Stepsize unit test.
 *      120207    K. Kumar          Adapted to use modified benchmark functions in Tudat Core.
 *      120213    K. Kumar          Modified getCurrentInterval() to getIndependentVariable();
 *                                  transferred to Boost unit test framework.
 *      120321    K. Kumar          Updated (Burden and Faires, 2011) benchmark function call.
 *      120323    K. Kumar          Rewrote unit tests to use benchmark data from
 *                                  (Burden and Faires, 2011); removed test against benchmark
 *                                  functions; renamed file to RFK45 unit test. Other unit tests
 *                                  for other Runge-Kutta methods will appear in other dedicated
 *                                  unit test files.
 *      120327    K. Kumar          Added missing comments; added unit test based on output data
 *                                  generated by (The Mathworks, 2012).
 *      120328    K. Kumar          Moved (Burden and Faires, 2011) test class to its own file;
 *                                  modified MATLAB unit tests to test forward and backwards in
 *                                  time and "forced" and "free" adaptive step size adjustment and
 *                                  moved to separate file (added call to function to run Matlab
 *                                  tests); added rollback tests for all cases.
 *      120404    K. Kumar          Updated Matlab unit test by adding discrete-event data file.
 *      130118    K. Kumar          Rewrote unit test to make use of testing code for numerical
 *                                  integrators migrated to Tudat Core.
 *      130906    K. Kumar          Updated error tolerances for MuPAD-based tests.
 *
 *      160321    R. Hoogendoorn    Created Runge Kutta 56 test
 *
 *    References
 *      Burden, R.L., Faires, J.D. Numerical Analysis, 7th Edition, Books/Cole, 2001.
 *      Montenbruck, O., Gill, E. Satellite Orbits: Models, Methods, Applications, Springer, 2005.
 *      The MathWorks, Inc. RKF54b, Symbolic Math Toolbox, 2012.
 *
 *    Notes
 *      For the tests using data from the Symbolic Math Toolbox (MathWorks, 2012), the single step
 *      and full integration error tolerances were picked to be as small as possible, without
 *      causing the tests to fail. These values are not deemed to indicate any bugs in the code;
 *      however, it is important to take these discrepancies into account when using this numerical
 *      integrator.
 *
 */

#define BOOST_TEST_MAIN

#include <iostream>
#include <limits>
#include <string>

#include <math.h>

#include <Eigen/Core>

#include <boost/test/unit_test.hpp>

#include "Tudat/Mathematics/NumericalIntegrators/rungeKuttaVariableStepSizeIntegrator.h"
#include "Tudat/Mathematics/NumericalIntegrators/rungeKuttaCoefficients.h"
#include "Tudat/Mathematics/NumericalIntegrators/UnitTests/numericalIntegratorTestFunctions.h"

namespace tudat
{
namespace unit_tests
{

BOOST_AUTO_TEST_SUITE( test_runge_kutta_fehlberg_56_integrator )

using numerical_integrator_test_functions::computeNonAutonomousModelStateDerivative;
using numerical_integrator_test_functions::computeVanDerPolStateDerivative ;
using numerical_integrator_test_functions::computeFehlbergLogirithmicTestODEStateDerivative ;
using numerical_integrator_test_functions::computeAnalyticalStateFehlbergODE ;

//! Compare with analytical solution of Fehlberg
BOOST_AUTO_TEST_CASE( test_RungeKuttaFehlberg56_Integrator_Fehlberg_Benchmark )
{
    tudat::numerical_integrators::RungeKuttaCoefficients coeff56 =
            tudat::numerical_integrators::RungeKuttaCoefficients::get(
                tudat::numerical_integrators::RungeKuttaCoefficients::rungeKuttaFehlberg56) ;

    // Integrator settings
    double minimumStepSize   = std::numeric_limits<double>::epsilon() ;
    double maximumStepSize   = std::numeric_limits<double>::infinity() ;
    double initialStepSize   = 1E-6; // Don't make this too small
    double relativeTolerance = 1E-16;
    double absoluteTolerance = 1E-16;

    // Initial conditions
    double initialTime = 0.0;
    double finalTime   = 5.0;
    Eigen::Vector2d initialState(exp(1.0), 1.0);

    // Setup integrator
    tudat::numerical_integrators::RungeKuttaVariableStepSizeIntegratorXd integrator56(
                coeff56, computeFehlbergLogirithmicTestODEStateDerivative ,
                initialTime , initialState, minimumStepSize,
                maximumStepSize, relativeTolerance, absoluteTolerance );


    // Obtain numerical solution
    Eigen::Vector2d numSol = integrator56.integrateTo(finalTime, initialStepSize);

    // Analytical solution
    // (page 30, Fehlberg, E. (1968). Classical Fifth-, Sixth-, Seventh- and Eigth-Order Runge-Kutta Formalas with Stepsize Control)
    Eigen::Vector2d anaSol = computeAnalyticalStateFehlbergODE(finalTime, initialState) ;

    Eigen::Vector2d computedError = numSol - anaSol;
    BOOST_CHECK_SMALL( std::fabs(computedError(0)) , 1E-12 ) ;
    BOOST_CHECK_SMALL( std::fabs(computedError(1)) , 1E-12 ) ;

    // Error calculated by -> Fehlberg, E. (1968) page 30
    // Initial stepsize unknown..
    Eigen::VectorXd FehlbergError(2) ;
    FehlbergError << 0.1072E-12 , -0.2190E-12 ;

    // sign check
    // Not always same sign -> initial step size = 1 or 1E-2, failure: computedError(1) , FehlbergError(1) not same sign
    BOOST_CHECK_GE(computedError(0)/FehlbergError(0) ,0.0);
    BOOST_CHECK_GE(computedError(1)/FehlbergError(1) ,0.0);

    // Check error is similar
    BOOST_CHECK_SMALL(std::fabs(computedError(0)/FehlbergError(0)), 3.0);
    BOOST_CHECK_SMALL(std::fabs(computedError(1)/FehlbergError(1)), 1.0);
}


//! Test Compare with Runge Kutta 78
BOOST_AUTO_TEST_CASE( test_RungeKuttaFehlberg56_Integrator_Compare78 )
{
    // Setup integrator
    tudat::numerical_integrators::RungeKuttaCoefficients Coeff56 =
            tudat::numerical_integrators::RungeKuttaCoefficients::get(
                tudat::numerical_integrators::RungeKuttaCoefficients::rungeKuttaFehlberg56) ;

    tudat::numerical_integrators::RungeKuttaCoefficients Coeff78 =
            tudat::numerical_integrators::RungeKuttaCoefficients::get(
                tudat::numerical_integrators::RungeKuttaCoefficients::rungeKuttaFehlberg78) ;

    // Integrator settings
    double MinimumStepSize = std::numeric_limits<double>::epsilon() ;
    double MaximumStepSize = std::numeric_limits<double>::infinity() ;
    double InitialStepSize = 1E-4; // Don't make this too small
    double RelativeTolerance = 1E-15 ;
    double AbsoluteTolerance = 1E-15 ;

    // Initial conditions
    double InitialTime = 0.5 ;
    Eigen::VectorXd InitialState(1) ;
    InitialState << 0.5  ; // 1 large error

    // Setup integrator
    tudat::numerical_integrators::RungeKuttaVariableStepSizeIntegratorXd integrator56(
                Coeff56, computeNonAutonomousModelStateDerivative, InitialTime , InitialState, MinimumStepSize,
                MaximumStepSize, RelativeTolerance, AbsoluteTolerance );

    tudat::numerical_integrators::RungeKuttaVariableStepSizeIntegratorXd integrator78(
                Coeff78, computeNonAutonomousModelStateDerivative, InitialTime , InitialState, MinimumStepSize,
                MaximumStepSize, RelativeTolerance, AbsoluteTolerance );

    double EndTime = 1.5 ;
    Eigen::VectorXd Solution56 = integrator56.integrateTo(EndTime,InitialStepSize) ;
    Eigen::VectorXd Solution78 = integrator78.integrateTo(EndTime,InitialStepSize) ;

    Eigen::VectorXd Difference = Solution78 - Solution56 ;

    BOOST_CHECK_SMALL( std::fabs(Difference(0)) , 1E-13 ) ;
}

//! Test Compare with Runge Kutta 78
BOOST_AUTO_TEST_CASE( test_RungeKuttaFehlberg56_Integrator_Compare78_v2 )
{
    // Setup integrator
    tudat::numerical_integrators::RungeKuttaCoefficients Coeff56 =
            tudat::numerical_integrators::RungeKuttaCoefficients::get(
                tudat::numerical_integrators::RungeKuttaCoefficients::rungeKuttaFehlberg56) ;

    tudat::numerical_integrators::RungeKuttaCoefficients Coeff78 =
            tudat::numerical_integrators::RungeKuttaCoefficients::get(
                tudat::numerical_integrators::RungeKuttaCoefficients::rungeKuttaFehlberg78) ;

    // Integrator settings
    double MinimumStepSize = std::numeric_limits<double>::epsilon() ;
    double MaximumStepSize = std::numeric_limits<double>::infinity() ;
    double InitialStepSize = 1; // Don't make this too small
    double RelativeTolerance = 1E-10 ;
    double AbsoluteTolerance = 1E-10 ;

    // Initial conditions
    double InitialTime = 0.2 ;
    Eigen::VectorXd InitialState(1) ;
    InitialState << -1.0  ;

    // Setup integrator
    tudat::numerical_integrators::RungeKuttaVariableStepSizeIntegratorXd integrator56(
                Coeff56, computeNonAutonomousModelStateDerivative, InitialTime , InitialState, MinimumStepSize,
                MaximumStepSize, RelativeTolerance, AbsoluteTolerance );

    tudat::numerical_integrators::RungeKuttaVariableStepSizeIntegratorXd integrator78(
                Coeff78, computeNonAutonomousModelStateDerivative, InitialTime , InitialState, MinimumStepSize,
                MaximumStepSize, RelativeTolerance, AbsoluteTolerance );

    double EndTime = 2.0 ;
    Eigen::VectorXd Solution56 = integrator56.integrateTo(EndTime,InitialStepSize) ;
    Eigen::VectorXd Solution78 = integrator78.integrateTo(EndTime,InitialStepSize) ;

    Eigen::VectorXd Difference = Solution78 - Solution56 ;

    BOOST_CHECK_SMALL( std::fabs(Difference(0)) , 1E-8 ) ;
}

//! Test Compare with Runge Kutta 78
BOOST_AUTO_TEST_CASE( test_RungeKuttaFehlberg56_Integrator_Compare78_VanDerPol )
{
    // Setup integrator
    tudat::numerical_integrators::RungeKuttaCoefficients Coeff56 =
            tudat::numerical_integrators::RungeKuttaCoefficients::get(
                tudat::numerical_integrators::RungeKuttaCoefficients::rungeKuttaFehlberg56) ;

    tudat::numerical_integrators::RungeKuttaCoefficients Coeff78 =
            tudat::numerical_integrators::RungeKuttaCoefficients::get(
                tudat::numerical_integrators::RungeKuttaCoefficients::rungeKuttaFehlberg78) ;

    // Integrator settings
    double MinimumStepSize = std::numeric_limits<double>::epsilon() ;
    double MaximumStepSize = std::numeric_limits<double>::infinity() ;
    double InitialStepSize = 1; // Don't make this too small
    double RelativeTolerance = 1E-15 ;
    double AbsoluteTolerance = 1E-15 ;

    // Initial conditions
    double InitialTime = 0.2 ;
    Eigen::VectorXd InitialState(2) ;
    InitialState << -1.0 , 1.0  ;

    // Setup integrator
    tudat::numerical_integrators::RungeKuttaVariableStepSizeIntegratorXd integrator56(
                Coeff56, computeVanDerPolStateDerivative, InitialTime , InitialState, MinimumStepSize,
                MaximumStepSize, RelativeTolerance, AbsoluteTolerance );

    tudat::numerical_integrators::RungeKuttaVariableStepSizeIntegratorXd integrator78(
                Coeff78, computeVanDerPolStateDerivative, InitialTime , InitialState, MinimumStepSize,
                MaximumStepSize, RelativeTolerance, AbsoluteTolerance );

    double EndTime = 1.4 ;
    Eigen::VectorXd Solution56 = integrator56.integrateTo(EndTime,InitialStepSize) ;
    Eigen::VectorXd Solution78 = integrator78.integrateTo(EndTime,InitialStepSize) ;

    Eigen::VectorXd Difference = Solution78 - Solution56 ;

    BOOST_CHECK_SMALL( std::fabs(Difference(0)) , 1E-13 ) ;
    BOOST_CHECK_SMALL( std::fabs(Difference(1)) , 1E-13 ) ;
}

BOOST_AUTO_TEST_SUITE_END( )

} // namespace unit_tests
} // namespace tudat
